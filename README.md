# SAT_Sudoku_solver
1.求解特定文件格式表示的SAT问题 2.将双数独转化为SAT问题求解并用挖洞法生成双数独

###SAT求解器

#####1. 运行方法
运行test.exe可执行程序，在选择界面输入1，代表运行sat求解器，如然后输入.cnf格式的文件名（输入的文件名不含.cnf后缀）。
在运行过程中会在控制台上显示求解进度的百分比，百分比代表着算法在二叉搜索树上运行的进度。对于不满足算例，在百分比达到100%时二叉搜索树遍历完成，运算结束；对于满足算例，求解出结果时的求解进度百分比不确定，从0-100%均有可能。

#####2. 策略选择
SAT求解器使用了DPLL算法，一共采取了四种选择单子句的方法：
    1.选择第一个变元
    2.选择最短子句的第一个变元
    3.选择出现次数最多的变元
    4.将一开始所有变元出现次数排序，按顺序选择变元

#####3. sat存储数据结构
使用一个简单的十字链表存储sat。每一个子句（clause）用一个链表表示，所有子句的头结点又用一个链表相连。

#####4. 两种递归方法
在本程序中，我实现了两种递归方式，分别写入函数DPLL_v2()（复制法）和DPLL()（回溯法）。
######4.1 赋值sat链表进行递归
在每次递归进入分支之前，复制当前的sat链表传入下一层递归当中。
优点是在每次结束一层递归回退到上一层时可以直接使用上一层栈中的sat链表，且支持多线程并行计算。
缺点是复制树需要时间，且空间复杂度为O(logn)个sat链表。除此之外，由于频繁的释放小块内存空间，复制树的方法可能造成大量内存空洞，使得长时间运行下内存占用率大量上涨，对于某些大型算例可能有内存溢出的风险。
######4.2 回溯法进行递归
用一个栈记录每次操作下，从sat链表中删去的结点和子句，并在一次递归调用完成后回溯，即从栈中退回上一步所删去的结点和子句。
优点是空间占用小，为1个sat链表的空间，且不会造成内存空洞。
缺点是进行回溯操作需要消耗时间，相比之下复制法直接存储了上一层递归的sat链表可以直接使用。除此之外，回溯法难以支持多线程并行计算。

###双数独生成和求解
#####1. 双数独求解
首先值得说明的一点是，为了最高效地求解双数独转化为的sat问题，我们的转化方式并不是越精简越好。相反，大量的冗余信息可以加速sat的求解速度。
最精简的方法是这样的，用a（0，1），b（0-8），c（0-8），d（1-9）分别代表千百十个位以表示a上（1代表左上，0代表右下）b行c列的空格填上d这一事件的真假性的布尔变元。
约束一个双数独可以用这种方式：
1. 每一行、列、九宫格均出现了1、2、3、......9
    “1101 1111 1121 1131 1141 1151 1161 1171 1181” 代表左上数独的第二行（行号为1）总有一列出现了1.
2. 每一个格子内只允许出现一个数，也就是一个格子只能填一个数（这是显然的）。
    以下用左上数独第三行（行号为2）第四列（列号为3）的格子举例。
    “-1231 -1232” 该格子不能同时为1和2
    “-1231 -1233” 该格子不能同时为1和3
    “-1231 -1234”
    ......
    "-1232 -1233"
    "-1232 -1234"
    ......
    "-1238 -1239"
3. 对于已经提前填好的格子，用单子句表示。
    “1001” 题目条件：左上数独的第一行第一列为1

这样，根据抽屉原理，必然可以保证数独的填写方法是合法的。
但是经过实验，这样的sat求解起来非常慢。为了让更多变元能在单层递归中被判断，我们应增加双子句的数量，也就是增加更多冗余条件。比如：

4. 对于每一行、列，同一个数只允许出现一次。

这个条件会增加大量的双子句，反而会加速我们的求解。
#####2. 双数独的生成
采用挖洞法，可以从一个初始的合法双数独终盘开始，随机生成一个有唯一解的双数独。
大致思路为，每挖去一个新的洞，用sat的求解方法判断，往新挖去的这个洞中填入一个不同于挖去前的数，整个数独是否有解。若有解，说明数独的答案不唯一，这便不符合我们对数独的要求。